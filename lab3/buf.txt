#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <atomic>
#include <chrono>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>
#include <memory>

#if defined(_WIN32)
    #include <windows.h>
    #include <process.h>
    #include <tchar.h>
    #define getpid _getpid
    #define fork() 0  // Заглушка для Windows
#else
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <signal.h>
#endif

// Включаем ваши библиотеки
#include "cplib_shmem.hpp"
#include "cplib_thread.hpp"

// Структура для разделяемой памяти
struct SharedData {
    int counter;
    bool is_master;
    pid_t master_pid;
    time_t last_fork_time;
    pid_t child1_pid;
    pid_t child2_pid;
    bool child1_running;
    bool child2_running;
};

// Глобальные переменные
std::unique_ptr<cplib::SharedMem<SharedData>> g_shared_mem;
std::ofstream g_log_file;
std::string g_log_filename = "counter_app.log";
std::atomic<bool> g_running(true);
std::atomic<bool> g_is_master(false);
std::atomic<bool> g_is_child(false);
std::atomic<int> g_child_type(0); // 0 = основной, 1 = child1, 2 = child2
cplib::Mutex g_log_mutex;

// Функции для работы со временем
std::string get_current_time_string(bool with_ms = false) {
    auto now = std::chrono::system_clock::now();
    auto now_time_t = std::chrono::system_clock::to_time_t(now);
    auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;
    
    std::tm tm_buf;
#if defined(_WIN32)
    localtime_s(&tm_buf, &now_time_t);
#else
    localtime_r(&now_time_t, &tm_buf);
#endif
    
    std::ostringstream oss;
    oss << std::put_time(&tm_buf, "%Y-%m-%d %H:%M:%S");
    if (with_ms) {
        oss << '.' << std::setfill('0') << std::setw(3) << now_ms.count();
    }
    return oss.str();
}

// Функция логирования
void log_message(const std::string& message, bool to_console = true) {
    cplib::AutoMutex lock(g_log_mutex);
    
    if (g_log_file.is_open()) {
        g_log_file << get_current_time_string(true) << " [PID: " << getpid();
        if (g_is_child) {
            g_log_file << " Child" << g_child_type;
        }
        g_log_file << "] " << message << std::endl;
        g_log_file.flush();
    }
    
    if (to_console) {
        std::cout << get_current_time_string(true) << " [PID: " << getpid();
        if (g_is_child) {
            std::cout << " Child" << g_child_type;
        }
        std::cout << "] " << message << std::endl;
    }
}

// Функция для дочернего процесса 1
void run_child1() {
    g_is_child = true;
    g_child_type = 1;
    
    // Записываем время запуска
    log_message("Child1 started");
    
    // Открываем разделяемую память
    cplib::SharedMem<SharedData> local_shared_mem("counter_app_shared");
    if (!local_shared_mem.IsValid()) {
        log_message("Child1: Failed to open shared memory");
        return;
    }
    
    // Увеличиваем счетчик на 10
    local_shared_mem.Lock();
    SharedData* data = local_shared_mem.Data();
    if (data) {
        data->counter += 10;
        log_message("Child1: Added 10 to counter. New value: " + std::to_string(data->counter));
    }
    local_shared_mem.Unlock();
    
    // В Windows сбрасываем флаг запуска
#if defined(_WIN32)
    if (g_shared_mem && g_shared_mem->IsValid()) {
        g_shared_mem->Lock();
        SharedData* master_data = g_shared_mem->Data();
        if (master_data) {
            master_data->child1_running = false;
        }
        g_shared_mem->Unlock();
    }
#endif
    
    // Записываем время выхода
    log_message("Child1 exited");
}

// Функция для дочернего процесса 2
void run_child2() {
    g_is_child = true;
    g_child_type = 2;
    
    // Записываем время запуска
    log_message("Child2 started");
    
    // Открываем разделяемую память
    cplib::SharedMem<SharedData> local_shared_mem("counter_app_shared");
    if (!local_shared_mem.IsValid()) {
        log_message("Child2: Failed to open shared memory");
        return;
    }
    
    // Сохраняем оригинальное значение и увеличиваем счетчик в 2 раза
    local_shared_mem.Lock();
    SharedData* data = local_shared_mem.Data();
    int original_value = 0;
    if (data) {
        original_value = data->counter;
        data->counter *= 2;
        log_message("Child2: Multiplied counter by 2. New value: " + std::to_string(data->counter));
    }
    local_shared_mem.Unlock();
    
    // Ждем 2 секунды
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // Уменьшаем счетчик в 2 раза (возвращаем к исходному значению)
    local_shared_mem.Lock();
    data = local_shared_mem.Data();
    if (data) {
        data->counter = original_value;
        log_message("Child2: Divided counter by 2. Restored value: " + std::to_string(data->counter));
    }
    local_shared_mem.Unlock();
    
    // В Windows сбрасываем флаг запуска
#if defined(_WIN32)
    if (g_shared_mem && g_shared_mem->IsValid()) {
        g_shared_mem->Lock();
        SharedData* master_data = g_shared_mem->Data();
        if (master_data) {
            master_data->child2_running = false;
        }
        g_shared_mem->Unlock();
    }
#endif
    
    // Записываем время выхода
    log_message("Child2 exited");
}

// Запуск дочернего процесса (кроссплатформенный)
bool launch_child_process(int child_type) {
#if defined(_WIN32)
    // Windows реализация - запуск в отдельном потоке
    std::thread child_thread;
    if (child_type == 1) {
        child_thread = std::thread(run_child1);
    } else {
        child_thread = std::thread(run_child2);
    }
    child_thread.detach(); // Отсоединяем поток
    return true;
#else
    // Linux реализация - через fork
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        if (child_type == 1) {
            run_child1();
        } else {
            run_child2();
        }
        exit(0);
    } else if (pid > 0) {
        // Родительский процесс
        return true;
    }
    return false;
#endif
}

// Таймер для увеличения счетчика каждые 300 мс
void timer_thread_func() {
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
        
        if (g_shared_mem && g_shared_mem->IsValid()) {
            g_shared_mem->Lock();
            SharedData* data = g_shared_mem->Data();
            if (data) {
                data->counter++;
                // Логируем только каждое 10-е увеличение, чтобы не засорять логи
                static int log_counter = 0;
                if (++log_counter >= 10 && g_is_master) {
                    log_counter = 0;
                    log_message("Timer: Counter incremented to " + std::to_string(data->counter), false);
                }
            }
            g_shared_mem->Unlock();
        }
    }
}

// Поток для записи в лог каждую секунду
void log_thread_func() {
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        
        if (g_is_master && g_shared_mem && g_shared_mem->IsValid()) {
            g_shared_mem->Lock();
            SharedData* data = g_shared_mem->Data();
            if (data) {
                std::ostringstream oss;
                oss << "Master log: Counter = " << data->counter;
                log_message(oss.str(), false);
            }
            g_shared_mem->Unlock();
        }
    }
}

// Поток для запуска копий каждые 3 секунды
void fork_thread_func() {
    while (g_running) {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        
        if (g_is_master && g_shared_mem && g_shared_mem->IsValid()) {
            g_shared_mem->Lock();
            SharedData* data = g_shared_mem->Data();
            
            if (data) {
                // Проверяем, завершились ли предыдущие копии
#if defined(_WIN32)
                // В Windows используем потоки, проверяем флаги
                bool can_fork = true;
                if (data->child1_running) {
                    can_fork = false;
                    log_message("Skipping fork: Child1 still running (Windows thread)", false);
                }
                if (data->child2_running) {
                    can_fork = false;
                    log_message("Skipping fork: Child2 still running (Windows thread)", false);
                }
                
                if (can_fork) {
                    // Запускаем копию 1
                    data->child1_running = true;
                    data->child1_pid = getpid(); // В Windows используем PID родителя
                    g_shared_mem->Unlock();
                    
                    if (launch_child_process(1)) {
                        log_message("Launched Child1 (Windows thread)", false);
                    }
                    
                    // Небольшая пауза между запусками
                    std::this_thread::sleep_for(std::chrono::milliseconds(100));
                    
                    g_shared_mem->Lock();
                    // Запускаем копию 2
                    data->child2_running = true;
                    data->child2_pid = getpid();
                    g_shared_mem->Unlock();
                    
                    if (launch_child_process(2)) {
                        log_message("Launched Child2 (Windows thread)", false);
                    }
                    
                    // Снова блокируем для обновления времени
                    g_shared_mem->Lock();
                    data->last_fork_time = time(nullptr);
                }
#else
                // Linux реализация - проверяем PID
                bool can_fork = true;
                
                if (data->child1_pid != 0) {
                    if (waitpid(data->child1_pid, NULL, WNOHANG) == 0) {
                        // Процесс еще работает
                        can_fork = false;
                        log_message("Skipping fork: Child1 still running (PID: " + 
                                   std::to_string(data->child1_pid) + ")", false);
                    } else {
                        // Процесс завершился
                        data->child1_pid = 0;
                    }
                }
                
                if (data->child2_pid != 0) {
                    if (waitpid(data->child2_pid, NULL, WNOHANG) == 0) {
                        can_fork = false;
                        log_message("Skipping fork: Child2 still running (PID: " + 
                                   std::to_string(data->child2_pid) + ")", false);
                    } else {
                        data->child2_pid = 0;
                    }
                }
                
                if (can_fork) {
                    // Запускаем копию 1
                    pid_t pid1 = fork();
                    if (pid1 == 0) {
                        // Дочерний процесс 1
                        run_child1();
                        exit(0);
                    } else if (pid1 > 0) {
                        data->child1_pid = pid1;
                        log_message("Launched Child1 (PID: " + std::to_string(pid1) + ")", false);
                    }
                    
                    // Запускаем копию 2
                    pid_t pid2 = fork();
                    if (pid2 == 0) {
                        // Дочерний процесс 2
                        run_child2();
                        exit(0);
                    } else if (pid2 > 0) {
                        data->child2_pid = pid2;
                        log_message("Launched Child2 (PID: " + std::to_string(pid2) + ")", false);
                    }
                    
                    data->last_fork_time = time(nullptr);
                }
#endif
            }
            g_shared_mem->Unlock();
        }
    }
}

// Обработка командной строки
void handle_user_input() {
    std::cout << "\n=== Counter Application ===" << std::endl;
    std::cout << "PID: " << getpid() << std::endl;
    std::cout << "Status: " << (g_is_master ? "MASTER" : "SLAVE") << std::endl;
    std::cout << "\nCommands:" << std::endl;
    std::cout << "  set <value>  - Set counter value" << std::endl;
    std::cout << "  get          - Get current counter value" << std::endl;
    std::cout << "  status       - Show application status" << std::endl;
    std::cout << "  exit         - Exit application" << std::endl;
    std::cout << "  help         - Show this help" << std::endl;
    std::cout << "================================\n" << std::endl;
    
    while (g_running) {
        std::cout << "> ";
        std::string command;
        if (!std::getline(std::cin, command)) {
            break; // EOF или ошибка ввода
        }
        
        if (command == "exit" || command == "quit") {
            g_running = false;
            break;
        } else if (command == "get") {
            if (g_shared_mem && g_shared_mem->IsValid()) {
                g_shared_mem->Lock();
                SharedData* data = g_shared_mem->Data();
                if (data) {
                    std::cout << "Current counter value: " << data->counter << std::endl;
                }
                g_shared_mem->Unlock();
            } else {
                std::cout << "Shared memory not available" << std::endl;
            }
        } else if (command.substr(0, 4) == "set ") {
            try {
                int value = std::stoi(command.substr(4));
                if (g_shared_mem && g_shared_mem->IsValid()) {
                    g_shared_mem->Lock();
                    SharedData* data = g_shared_mem->Data();
                    if (data) {
                        data->counter = value;
                        std::cout << "Counter set to: " << value << std::endl;
                        log_message("User set counter to " + std::to_string(value));
                    }
                    g_shared_mem->Unlock();
                }
            } catch (const std::exception& e) {
                std::cout << "Invalid value: " << e.what() << std::endl;
            }
        } else if (command == "status") {
            if (g_shared_mem && g_shared_mem->IsValid()) {
                g_shared_mem->Lock();
                SharedData* data = g_shared_mem->Data();
                if (data) {
                    std::cout << "\n=== Application Status ===" << std::endl;
                    std::cout << "Counter value: " << data->counter << std::endl;
                    std::cout << "Is master: " << (data->is_master ? "Yes" : "No") << std::endl;
                    std::cout << "Master PID: " << data->master_pid << std::endl;
                    std::cout << "This PID: " << getpid() << std::endl;
                    std::cout << "Child1 PID: " << data->child1_pid << std::endl;
                    std::cout << "Child2 PID: " << data->child2_pid << std::endl;
                    std::cout << "Last fork: " << ctime(&data->last_fork_time);
                    std::cout << "===========================\n" << std::endl;
                }
                g_shared_mem->Unlock();
            }
        } else if (command == "help") {
            std::cout << "\nCommands:" << std::endl;
            std::cout << "  set <value>  - Set counter value" << std::endl;
            std::cout << "  get          - Get current counter value" << std::endl;
            std::cout << "  status       - Show application status" << std::endl;
            std::cout << "  exit         - Exit application" << std::endl;
            std::cout << "  help         - Show this help" << std::endl;
        } else if (!command.empty()) {
            std::cout << "Unknown command. Type 'help' for help." << std::endl;
        }
    }
}

// Основная функция
int main(int argc, char* argv[]) {
    // Проверяем, не является ли это специальным запуском дочернего процесса
    if (argc > 1) {
        std::string arg = argv[1];
        if (arg == "child1") {
            run_child1();
            return 0;
        } else if (arg == "child2") {
            run_child2();
            return 0;
        }
    }
    
    // Основной процесс
    // Открываем лог файл
    g_log_file.open(g_log_filename, std::ios::app);
    if (!g_log_file.is_open()) {
        std::cerr << "Failed to open log file: " << g_log_filename << std::endl;
        return 1;
    }
    
    // Записываем время запуска
    std::string start_msg = "Application started";
    log_message(start_msg);
    
    // Открываем или создаем разделяемую память
    try {
        g_shared_mem = std::make_unique<cplib::SharedMem<SharedData>>("counter_app_shared", true);
    } catch (...) {
        std::cerr << "Failed to create/open shared memory" << std::endl;
        return 1;
    }
    
    if (!g_shared_mem->IsValid()) {
        std::cerr << "Shared memory is not valid" << std::endl;
        return 1;
    }
    
    // Инициализируем разделяемую память
    g_shared_mem->Lock();
    SharedData* shared_data = g_shared_mem->Data();
    
    // Проверяем, есть ли уже мастер
    bool master_exists = false;
    
    if (shared_data->counter == 0 && !shared_data->is_master) {
        // Первая программа или сброшенное состояние
        shared_data->counter = 0;
        shared_data->is_master = true;
        shared_data->master_pid = getpid();
        shared_data->last_fork_time = 0;
        shared_data->child1_pid = 0;
        shared_data->child2_pid = 0;
        shared_data->child1_running = false;
        shared_data->child2_running = false;
        g_is_master = true;
        log_message("This process is MASTER (initialized shared memory)");
    } else if (shared_data->is_master) {
        // Проверяем, жив ли мастер
        bool master_alive = false;
        
        if (shared_data->master_pid == getpid()) {
            // Это мы сами!
            master_alive = true;
        } else {
#if defined(_WIN32)
            HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, shared_data->master_pid);
            if (process) {
                DWORD exit_code;
                if (GetExitCodeProcess(process, &exit_code)) {
                    master_alive = (exit_code == STILL_ACTIVE);
                }
                CloseHandle(process);
            }
#else
            master_alive = (kill(shared_data->master_pid, 0) == 0);
#endif
        }
        
        if (master_alive) {
            master_exists = true;
            log_message("Master already exists (PID: " + std::to_string(shared_data->master_pid) + 
                       "). This process is SLAVE");
        } else {
            // Мастер умер, становимся мастером
            shared_data->is_master = true;
            shared_data->master_pid = getpid();
            shared_data->child1_pid = 0;
            shared_data->child2_pid = 0;
            shared_data->child1_running = false;
            shared_data->child2_running = false;
            g_is_master = true;
            log_message("Master died. This process is now MASTER");
        }
    } else {
        // Нет мастера, становимся мастером
        shared_data->is_master = true;
        shared_data->master_pid = getpid();
        g_is_master = true;
        log_message("No master found. This process is now MASTER");
    }
    
    g_shared_mem->Unlock();
    
    // Если мы не мастер, не запускаем логирование и форкинг
    if (g_is_master) {
        // Запускаем потоки только если мы мастер
        std::thread timer_thread(timer_thread_func);
        std::thread log_thread(log_thread_func);
        std::thread fork_thread(fork_thread_func);
        
        // Запускаем обработку команд пользователя
        handle_user_input();
        
        // Останавливаем все потоки
        g_running = false;
        
        if (timer_thread.joinable()) timer_thread.join();
        if (log_thread.joinable()) log_thread.join();
        if (fork_thread.joinable()) fork_thread.join();
    } else {
        // Слейв-процесс: только таймер и пользовательский ввод
        std::thread timer_thread(timer_thread_func);
        
        // Запускаем обработку команд пользователя
        handle_user_input();
        
        // Останавливаем таймер
        g_running = false;
        
        if (timer_thread.joinable()) timer_thread.join();
    }
    
    // Если мы мастер, очищаем флаг мастера перед выходом
    if (g_is_master && g_shared_mem && g_shared_mem->IsValid()) {
        g_shared_mem->Lock();
        SharedData* data = g_shared_mem->Data();
        if (data && data->master_pid == getpid()) {
            data->is_master = false;
            data->master_pid = 0;
            log_message("Master shutting down");
        }
        g_shared_mem->Unlock();
    }
    
    // Закрываем лог файл
    log_message("Application stopped");
    g_log_file.close();
    
    return 0;
}